// Generated by https://quicktype.io

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class ListingLatestCmKapCs
    {
        [JsonProperty("status")]
        public Status Status { get; set; }

        [JsonProperty("data")]
        public Datum[] Data { get; set; }
    }

    public partial class Datum
    {
        [JsonProperty("id")]
        public long Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("symbol")]
        public string Symbol { get; set; }

        [JsonProperty("slug")]
        public string Slug { get; set; }

        [JsonProperty("num_market_pairs")]
        public long NumMarketPairs { get; set; }

        [JsonProperty("date_added")]
        public DateTimeOffset DateAdded { get; set; }

        [JsonProperty("tags")]
        public string[] Tags { get; set; }

        [JsonProperty("max_supply")]
        public double? MaxSupply { get; set; }

        [JsonProperty("circulating_supply")]
        public double CirculatingSupply { get; set; }

        [JsonProperty("total_supply")]
        public double TotalSupply { get; set; }

        [JsonProperty("platform")]
        public Platform Platform { get; set; }

        [JsonProperty("cmc_rank")]
        public long CmcRank { get; set; }

        [JsonProperty("last_updated")]
        public DateTimeOffset LastUpdated { get; set; }

        [JsonProperty("quote")]
        public Quote Quote { get; set; }
    }

    public partial class Platform
    {
        [JsonProperty("id")]
        public long Id { get; set; }

        [JsonProperty("name")]
        public Name Name { get; set; }

        [JsonProperty("symbol")]
        public Symbol Symbol { get; set; }

        [JsonProperty("slug")]
        public Slug Slug { get; set; }

        [JsonProperty("token_address")]
        public string TokenAddress { get; set; }
    }

    public partial class Quote
    {
        [JsonProperty("USD")]
        public Usd Usd { get; set; }
    }

    public partial class Usd
    {
        [JsonProperty("price")]
        public double Price { get; set; }

        [JsonProperty("volume_24h")]
        public double Volume24H { get; set; }

        [JsonProperty("percent_change_1h")]
        public double PercentChange1H { get; set; }

        [JsonProperty("percent_change_24h")]
        public double PercentChange24H { get; set; }

        [JsonProperty("percent_change_7d")]
        public double PercentChange7D { get; set; }

        [JsonProperty("percent_change_30d")]
        public double PercentChange30D { get; set; }

        [JsonProperty("percent_change_60d")]
        public double PercentChange60D { get; set; }

        [JsonProperty("percent_change_90d")]
        public double PercentChange90D { get; set; }

        [JsonProperty("market_cap")]
        public double MarketCap { get; set; }

        [JsonProperty("last_updated")]
        public DateTimeOffset LastUpdated { get; set; }
    }

    public partial class Status
    {
        [JsonProperty("timestamp")]
        public DateTimeOffset Timestamp { get; set; }

        [JsonProperty("error_code")]
        public long ErrorCode { get; set; }

        [JsonProperty("error_message")]
        public object ErrorMessage { get; set; }

        [JsonProperty("elapsed")]
        public long Elapsed { get; set; }

        [JsonProperty("credit_count")]
        public long CreditCount { get; set; }

        [JsonProperty("notice")]
        public object Notice { get; set; }

        [JsonProperty("total_count")]
        public long TotalCount { get; set; }
    }

    public enum Name { Avalanche, BinanceChain, BinanceSmartChain, Chiliz, Eos, Ethereum, Heco, Iost, Neo, Polygon, Solana, Tron, Wanchain, XdaiChain };

    public enum Slug { Avalanche, BinanceCoin, Chiliz, Eos, Ethereum, HuobiToken, Iostoken, Neo, Polygon, Solana, Tron, Wanchain, Xdai };

    public enum Symbol { Avax, Bnb, Chz, Eos, Eth, Ht, Iost, Matic, Neo, Sol, Stake, Trx, Wan };

    public partial class ListingLatestCmKapCs
    {
        public static ListingLatestCmKapCs FromJson(string json) => JsonConvert.DeserializeObject<ListingLatestCmKapCs>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ListingLatestCmKapCs self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                NameConverter.Singleton,
                SlugConverter.Singleton,
                SymbolConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Avalanche":
                    return Name.Avalanche;
                case "Binance Chain":
                    return Name.BinanceChain;
                case "Binance Smart Chain":
                    return Name.BinanceSmartChain;
                case "Chiliz":
                    return Name.Chiliz;
                case "EOS":
                    return Name.Eos;
                case "Ethereum":
                    return Name.Ethereum;
                case "Heco":
                    return Name.Heco;
                case "IOST":
                    return Name.Iost;
                case "Neo":
                    return Name.Neo;
                case "Polygon":
                    return Name.Polygon;
                case "Solana":
                    return Name.Solana;
                case "Tron":
                    return Name.Tron;
                case "Wanchain":
                    return Name.Wanchain;
                case "Xdai chain":
                    return Name.XdaiChain;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.Avalanche:
                    serializer.Serialize(writer, "Avalanche");
                    return;
                case Name.BinanceChain:
                    serializer.Serialize(writer, "Binance Chain");
                    return;
                case Name.BinanceSmartChain:
                    serializer.Serialize(writer, "Binance Smart Chain");
                    return;
                case Name.Chiliz:
                    serializer.Serialize(writer, "Chiliz");
                    return;
                case Name.Eos:
                    serializer.Serialize(writer, "EOS");
                    return;
                case Name.Ethereum:
                    serializer.Serialize(writer, "Ethereum");
                    return;
                case Name.Heco:
                    serializer.Serialize(writer, "Heco");
                    return;
                case Name.Iost:
                    serializer.Serialize(writer, "IOST");
                    return;
                case Name.Neo:
                    serializer.Serialize(writer, "Neo");
                    return;
                case Name.Polygon:
                    serializer.Serialize(writer, "Polygon");
                    return;
                case Name.Solana:
                    serializer.Serialize(writer, "Solana");
                    return;
                case Name.Tron:
                    serializer.Serialize(writer, "Tron");
                    return;
                case Name.Wanchain:
                    serializer.Serialize(writer, "Wanchain");
                    return;
                case Name.XdaiChain:
                    serializer.Serialize(writer, "Xdai chain");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class SlugConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Slug) || t == typeof(Slug?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "avalanche":
                    return Slug.Avalanche;
                case "binance-coin":
                    return Slug.BinanceCoin;
                case "chiliz":
                    return Slug.Chiliz;
                case "eos":
                    return Slug.Eos;
                case "ethereum":
                    return Slug.Ethereum;
                case "huobi-token":
                    return Slug.HuobiToken;
                case "iostoken":
                    return Slug.Iostoken;
                case "neo":
                    return Slug.Neo;
                case "polygon":
                    return Slug.Polygon;
                case "solana":
                    return Slug.Solana;
                case "tron":
                    return Slug.Tron;
                case "wanchain":
                    return Slug.Wanchain;
                case "xdai":
                    return Slug.Xdai;
            }
            throw new Exception("Cannot unmarshal type Slug");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Slug)untypedValue;
            switch (value)
            {
                case Slug.Avalanche:
                    serializer.Serialize(writer, "avalanche");
                    return;
                case Slug.BinanceCoin:
                    serializer.Serialize(writer, "binance-coin");
                    return;
                case Slug.Chiliz:
                    serializer.Serialize(writer, "chiliz");
                    return;
                case Slug.Eos:
                    serializer.Serialize(writer, "eos");
                    return;
                case Slug.Ethereum:
                    serializer.Serialize(writer, "ethereum");
                    return;
                case Slug.HuobiToken:
                    serializer.Serialize(writer, "huobi-token");
                    return;
                case Slug.Iostoken:
                    serializer.Serialize(writer, "iostoken");
                    return;
                case Slug.Neo:
                    serializer.Serialize(writer, "neo");
                    return;
                case Slug.Polygon:
                    serializer.Serialize(writer, "polygon");
                    return;
                case Slug.Solana:
                    serializer.Serialize(writer, "solana");
                    return;
                case Slug.Tron:
                    serializer.Serialize(writer, "tron");
                    return;
                case Slug.Wanchain:
                    serializer.Serialize(writer, "wanchain");
                    return;
                case Slug.Xdai:
                    serializer.Serialize(writer, "xdai");
                    return;
            }
            throw new Exception("Cannot marshal type Slug");
        }

        public static readonly SlugConverter Singleton = new SlugConverter();
    }

    internal class SymbolConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Symbol) || t == typeof(Symbol?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AVAX":
                    return Symbol.Avax;
                case "BNB":
                    return Symbol.Bnb;
                case "CHZ":
                    return Symbol.Chz;
                case "EOS":
                    return Symbol.Eos;
                case "ETH":
                    return Symbol.Eth;
                case "HT":
                    return Symbol.Ht;
                case "IOST":
                    return Symbol.Iost;
                case "MATIC":
                    return Symbol.Matic;
                case "NEO":
                    return Symbol.Neo;
                case "SOL":
                    return Symbol.Sol;
                case "STAKE":
                    return Symbol.Stake;
                case "TRX":
                    return Symbol.Trx;
                case "WAN":
                    return Symbol.Wan;
            }
            throw new Exception("Cannot unmarshal type Symbol");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Symbol)untypedValue;
            switch (value)
            {
                case Symbol.Avax:
                    serializer.Serialize(writer, "AVAX");
                    return;
                case Symbol.Bnb:
                    serializer.Serialize(writer, "BNB");
                    return;
                case Symbol.Chz:
                    serializer.Serialize(writer, "CHZ");
                    return;
                case Symbol.Eos:
                    serializer.Serialize(writer, "EOS");
                    return;
                case Symbol.Eth:
                    serializer.Serialize(writer, "ETH");
                    return;
                case Symbol.Ht:
                    serializer.Serialize(writer, "HT");
                    return;
                case Symbol.Iost:
                    serializer.Serialize(writer, "IOST");
                    return;
                case Symbol.Matic:
                    serializer.Serialize(writer, "MATIC");
                    return;
                case Symbol.Neo:
                    serializer.Serialize(writer, "NEO");
                    return;
                case Symbol.Sol:
                    serializer.Serialize(writer, "SOL");
                    return;
                case Symbol.Stake:
                    serializer.Serialize(writer, "STAKE");
                    return;
                case Symbol.Trx:
                    serializer.Serialize(writer, "TRX");
                    return;
                case Symbol.Wan:
                    serializer.Serialize(writer, "WAN");
                    return;
            }
            throw new Exception("Cannot marshal type Symbol");
        }

        public static readonly SymbolConverter Singleton = new SymbolConverter();
    }
}
